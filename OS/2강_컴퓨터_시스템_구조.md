# 컴퓨터 시스템 구조  
https://jeong9216.tistory.com/315  

-------

## 컴퓨터 시스템 구조

[##_Image|kage@pda3a/btrwnPtIxLd/dPwyNQnXkosV24GgZbYVo1/img.png|CDM|1.3|{"originWidth":1084,"originHeight":836,"style":"alignCenter","width":600,"height":463,"caption":"컴퓨터 시스템 구조"}_##]

### CPU

CPU는 메모리에서 기계어를 읽어서 처리합니다.

연산을 수행하는 산술 논리 장치(ALU), 제어 명령을 전달하는 컨트롤 장치(CU), 결과 값을 일시적으로 저장하는 Registers가 포함됩니다.

### Memory

주기억장치이며 CPU의 작업 공간입니다. 운영체제와 프로세스 등이 메모리 공간에 올라갑니다.

CPU는 주기억장치에서 프로그램들의 기계어(명령어) 등을 읽어서 처리합니다.

### Mode Bit

사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호장치입니다.

Mode Bit을 통해 하드웨어적으로 두 가지 모드의 Operation을 지원합니다.

-   0(모니터 모드 = 커널 모드 = 시스템 모드) : OS 코드를 수행
-   1(사용자 모드) : 사용자 프로그램을 수행하는 모드. 제한된 기계어만 실행 가능

보안을 해칠 수 있는 중요한 명령어는 커널 모드에서만 수행 가능한 "특권 명령"으로 규정됩니다.

이런 명령어가 파악되면 interrupt 또는 Exception을 통해 자동으로 CPU가 운영체제로 넘어갑니다.

Interrupt 또는 Exception이 발생 시 하드웨어가 Mode Bit을 0으로 바꿉니다.

CPU가 사용자 프로그램으로 넘어가기 직전에 Mode Bit을 1로 바꿉니다.

### Register

아주 빠른 연산을 위한 Register가 붙어 있습니다.

Program Counter라는 Register는 다음번 실행할 명령어의 메모리 주소를 가리키고 있습니다.

### Timer

일정 시간 간격으로 타이머 Interrupt를 발생시킵니다.

운영체제가 사용자 프로그램에게 넘길 때 타이머에 시간을 세팅합니다.

무한 루프를 도는 등 CPU가 특정 프로그램에 의해 독점되는 것으로부터 보호합니다.

타이머는 Timer Sharing을 구현하기 위해 널리 이용되며 현재 시간을 계산하기 위해 사용되기도 합니다.

### I/O Device

입출력 장치란, 사용자가 원하는 문자나 그림의 데이터를 컴퓨터로 전달하거나 출력하는 장치입니다.

키보드, 마이크 등이 입력 장치이며 모니터, 스피커 등이 출력 장치입니다.

입출력 장치에는 작은 CPU 역할을 하는 Device Controller가 있으며 I/O 연산, 제어 관리를 합니다.

### Device Controller

Device Controller는 위에서 말했듯 I/O 장치를 관리하는 일종의 작은 CPU입니다.

제어 정보를 처리하기 위해 Control Register, Status Register를 가집니다.

-   Control Register : host에 의해 쓰인 명령어가 들어있음.
-   Control Register : 현재 명령이 처리되었는지, Data-in register에서 읽을 수 있는지, 장치에 문제가 있는지 등이 저장됨.

Local Buffer는 Device Controller에서 들어오고 나오는 데이터를 저장합니다. 즉, 램과 같은 역할을 합니다.

I/O는 실제 Device와 Local Buffer 사이에서 일어납니다.

Device Controller는 I/O가 끝났을 경우 Interrupt가 발생하여 CPU에게 알립니다.

#### Device Driver

Device Driver는 운영체제가 각각의 Device를 접근하게 하기 위한 인터페이스 역할을 하는 소프트웨어입니다.

### DMA Controller

DMA(Direct Memory Access) Controller는 메모리에 직접 전송이 가능한 Controller입니다.

일반적으로 I/O Device들은 메인 메모리에 직접 접근할 수 없고 I/O Device들은 인터럽트를 발생시켜 CPU가 I/O Device들의 데이터를 읽어 메인 메모리에 올립니다. CPU는 프로그램의 명령어를 처리하는 것 외에도 항상 각각의 I/O Device들 인터럽트에 대한 처리도 해야 하기 때문에 CPU의 효율성이 떨어집니다.

이러한 비효율성 때문에 I/O Device에 인터럽트를 처리할 컨트롤러를 하나 더 두었는데 이것이 DMA Controller입니다.

CPU의 중재 없이 DMA controller가 Device의 Buffer Storage의 내용을 메모리에 블록 단위로 직접 전송합니다.

따라서 CPU는 DMA Controller의 인터럽트만 처리하면 되기에 효율성이 증가합니다.

---

## Interrupt

CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외 상황이 발생하여 처리가 필요할 경우 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말합니다.

현대의 운영체제는 인터럽트에 의해 구동됩니다.

CPU는 인터럽트가 들어올 때만 작동하므로 항상 인터럽트를 통해 운영체제가 호출되도록 해야 합니다.

### Interrupt 분류

인터럽트는 크게 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉩니다.

-   Interrupt(하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트
-   Trap(소프트웨어 인터럽트) : 소프트웨어가 발생시킨 인터럽트
    -   System Call : 프로그램이 커널 함수를 호출하는 경우
    -   Exception : 프로그램이 오류를 범한 경우

대표적인 소프트웨어 인터럽트로는 System Call이 있습니다.

모든 I/O 장치에 접근하는 기계어들은 전부 특권 명령으로 묶여 있습니다. 특권 명령은 사용자 프로그램이 직접 호출을 못하고 운영체제에게 요청을 해야 합니다. 이때 사용자 프로그램은 System Call을 이용해 운영체제에게 요청합니다.

System Call이란 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것입니다.

사용자 프로그램이 직접 인터럽트를 발생시키며 CPU는 다음 기계어를 실행하기 전에 운영체제에게 CPU 제어권을 넘깁니다.

### Interrupt 제어권

인터럽트를 당한 시점의 Register와 Program Counter를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘깁니다.

CPU의 제어권이 변경되는 경우 몇 가지를 살펴보겠습니다.

-   CPU가 운영체제로 넘어가는 경우 : 공통적으로 Interrupt Line을 세팅하여 CPU가 읽도록 함
    -   하드웨어 장치들이 인터럽트를 발생시킨 경우
    -   사용자 프로그램이 본인에게 권한이 없는 기계어를 실행하려고 하는 경우
    -   사용자 프로그램에서 시스템 콜이 필요할 때 인터럽트를 발생시키는 경우
-   CPU를 빼앗기는 경우
    -   타이머 인터럽트가 발생한 경우
    -   I/O가 오래 걸리는 경우 : CPU 제어권을 가지고 있어도 할 수 있는 게 없어 제어권을 탈취당함

### Interrupt 처리

CPU는 인터럽트마다 해야 하는 일이 다릅니다.

인터럽트 벡터에 인터럽트 종류별로 실행해야 하는 코드의 주소를 가지고 있습니다.

이 코드를 인터럽트 처리 루틴이라고 합니다.

인터럽트 처리 루틴(Interrupt Service Routine, 인터럽트 핸들러)은 해당 인터럽트를 처리하는 커널 함수입니다.

### Interrupt 처리 루틴

인터럽트 처리 루틴이란 인터럽트가 발생한 경우에 처리해야 하는 절차를 의미합니다. 인터럽트 핸들링이라고도 합니다.

인터럽트는 발생 시 CPU에 의해 인터럽트 처리 루틴을 실행합니다.

CPU가 사용자 프로그램 처리 중 인터럽트가 발생하면 사용자 프로그램의 현재 수행 중이던 주소와 부가 정보를 저장해야 합니다.

인터럽트가 발생하면 Register의 기존 데이터들이 지워지기 때문입니다.

이를 위해 운영체제 커널 내에는 PCB(Process Control Block)이 존재합니다.

이 자료 구조에서 인터럽트가 발생했을 때 프로그램의 어느 부분이 수행되던 중이었는지를 저장합니다.

이를 바탕으로 CPU는 인터럽트가 발생했을 때 인터럽트 처리 후 원래 프로그램으로 돌아올 수 있습니다.

---

## I/O 방식

I/O는 동기식 입출력(Synchronous I/O)과 비동기식 입출력(Asynchronous I/O)이 있습니다.

[##_Image|kage@Vkynw/btrwrHBnfhS/ky7KDJKNNFrs0ZWxuG2D81/img.png|CDM|1.3|{"originWidth":1568,"originHeight":928,"style":"alignCenter","width":600,"height":355,"caption":"I/O 방식"}_##]

### 동기식 입출력(Synchronous I/O)

일반적인 I/O 입출력으로 I/O 요청 후 입출력 작업이 완료된 후에야 CPU 제어가 사용자 프로그램에 넘어갑니다.

I/O에서 일어나는 작업과 CPU에서 일어나는 작업이 Sync가 되어야 할 때 동기식 입출력을 사용합니다.

-   구현 방법 1 : I/O가 오래 걸릴 경우 CPU가 낭비된다.
    -   I/O가 끝날 때까지 CPU를 낭비 시킴
    -   매시점 하나의 I/O만 일어날 수 있음
-   구현 방법 2 : I/O 완료를 기다리는 동안 다른 프로그램에서 CPU를 사용하므로 더 효율적이다.
    -   I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
    -   I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
    -   다른 프로그램에게 CPU를 줌

입출력이 완료되면 인터럽트를 이용해 완료되었음을 알립니다.

### 비동기식 입출력(Asynchronous I/O)

I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어갑니다.

입출력 결과에 상관없이 수행할 수 있는 일들은 비동기식 입출력을 사용합니다.

예를 들어, write를 하는 경우 쓰인 결과에 상관없이 write를 이어갈 수 있으므로 비동기 방식이 사용 가능합니다.

입출력이 완료되면 인터럽트를 이용해 완료되었음을 알립니다.

---

## 저장 장치 계층 구조

[##_Image|kage@cVHGsY/btrwpZP5zeQ/QVzWlIFk9TpAXAfpLNGwh0/img.png|CDM|1.3|{"originWidth":1710,"originHeight":998,"style":"alignCenter","width":600,"height":350}_##]

Register 위에 CPU가 존재합니다.

컴퓨터 시스템을 구성하는 저장 장치는 단계적으로 계층 구조로 이루어집니다.

위로 갈수록 속도가 빠르고 단위 공간당 가격이 비싸서 용량이 적습니다.

Main Memory를 기준으로 메인 메모리 포함 위쪽과 아래쪽으로 특성이 나뉩니다. 

-   Main Memory 포함 위쪽
    -   전원이 끊기면 정보가 휘발되는 휘발성 매체임
    -   Byte 단위로 접근 가능하여 CPU에서 직접 접근이 가능함

-   Main Memory 아래
    -   전원이 끊겨도 정보가 휘발되지 않는 비휘발성 매체임
    -   섹터 단위로 접근하여 CPU에서 직접 접근이 불가능함.

최상단 계층과 최하단 계층 사이의 속도 차이를 완충하기 위해 Cache Memory를 배치합니다.

재사용될 정보를 저장해 두고 맨 아래 계층까지 이동하지 않고도 정보를 가져올 수 있습니다.

다만, 용량이 적어 당장 필요한 것만 저장합니다.

---

## 프로그램 실행(Memory Load)

[##_Image|kage@4tzdt/btrwmqnkYOL/YkZa3MXuGEVEYTsW1NSqjK/img.png|CDM|1.3|{"originWidth":1750,"originHeight":1110,"style":"alignCenter","width":600,"height":381}_##]

파일 시스템에 파일 형태로 저장되어 있는 실행 파일을 실행하면 메모리로 올라가서 프로세스가 됩니다.

정확하게는 물리적인 메모리에 바로 올라가는 것이 아닌 가상 메모리를 거쳐서 올라갑니다.

이 가상 메모리는 실제 할당되는 것이 아니며 물리 메모리 공간 + Swap Area를 나타냅니다.

물리 메모리에는 당장 필요한 부분만 올려 공간 효율을 높입니다.

당장 필요하지 않은 메모리는 Swap Area로 보냅니다.

물리 메모리와 Swap Area를 이동하려면 주소 변환이 이뤄져야 하는데 이는 추후 메모리 내용에서 다룹니다.

실행 파일을 실행시키면 그 프로그램의 Address Space(메모리 주소 공간)가 생깁니다.

각 프로그램마다 code, data, stack 영역으로 구성됩니다.

code

커널 코드, System Call, Interrupt 처리 코드, 자원 관리를 위한 코드 등 기계어 코드가 저장됩니다.

개발자가 작성한 코드도 code 영역에 저장됩니다.

data

전역 변수, 하드웨어를 관리하기 위해 필요한 자료구조가 저장됩니다.

프로세스마다 관리하는 PCB(Program Control Block)도 이에 포함됩니다.

stack

실행 중인 함수에서 다른 함수를 호출한 경우 호출된 함수의 return 값, 복귀 주소 등이 저장됩니다.
