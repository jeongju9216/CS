## 운영체제란?

하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층입니다.

사용자가 하드웨어적인 지식이 없어도 각종 애플리케이션 프로그램 등을 편하게 사용할 수 있도록 하는 것이 운영체제의 목적입니다.

컴퓨터 분야에서 가장 복잡하고 까다로운 소프트웨어로 볼 수 있습니다.

### 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공

운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상(illusion)을 제공합니다.

하드웨어를 직접 다루는 복잡한 부분을 사용자 대신 운영체제가 대행합니다.

### 컴퓨터 시스템의 자원을 효율적으로 관리

CPU, 메모리, I/O 장치 등을 효율적으로 관리합니다.

여러 프로그램에게 CPU를 번갈아 할당하거나 메모리 공간을 적절히 분배합니다.

CPU에서 프로그램이 실행되려면 메모리에 올려야 하는데 여러 프로그램이 동시에 실행될 때 어떤 메모리에 얼마큼 올려놔야 CPU에서 효율적으로 실행할 수 있는지를 계산합니다.

이때, 주어진 자원으로 최대한의 성능을 내도록 하는 효율성과 효율성을 극대화하기 위해 특정 사용자나 프로그램의 지나친 불이익이 발생하지 않도록 하는 형평성을 동시에 고려합니다.

---

## 운영체제 작업

운영체제는 컴퓨터 전원이 켜지면 메모리에 올라가 실행이 됩니다. 이를 부팅이라고 합니다.

운영체제는 컴퓨터가 꺼질 때까지 항상 실행이 되며 여러 작업을 처리합니다.

운영체제 개요 강의에서는 대략적으로만 소개됩니다.

### CPU 스케줄링

운영체제는 어떤 프로그램에게 CPU 사용권을 줄지를 계산하고 부여합니다.

아래 Waiting Time은 프로세스의 사용권을 중간에 박탈하지 않는다는 가정 하에 계산되었습니다.

#### Waiting Time

Waiting Time 이란 프로세스들이 도착하고 실행되기까지 대기하는 시간입니다.

CPU 사용 시간이 짧은 프로세스가 먼저 사용할수록 평균 Waiting Time은 줄어듭니다.

Starvation을 방지하면서 Waiting Time을 줄일수록 효율적입니다.

#### FCFS(First-Come First-Served)

선착순으로 사용권을 부여하는 방법입니다. 공평하다고 볼 수 있지만 효율적이지는 않습니다.

Waiting Time이 굉장히 길기 때문입니다.

CPU 사용 시간이 27초, 3초, 3초인 프로세스가 순서대로 들어온다면

A의 대기 시간은 0초, B의 대기 시간은 27초, C의 대기 시간은 30초로 평균 대기 시간은 19초입니다.

#### SJF(Shorted-Job-First)

금번 CPU 사용 시간이 가장 짧은 프로세스를 제일 먼저 스케줄 합니다.

SJF는 minimum average waiting time을 보장합니다.

3초, 3초, 27초 순서로 실행된다면 대기 시간은 각각 0초, 3초, 6초로 평균 대기 시간은 3초입니다.

단, 실행 시간이 항상 가장 긴 프로세스가 있을 때 이 프로세스는 영원히 스케줄링될 수 없습니다.

이런 현상을 Starvation(기아 현상)이라고 합니다.

#### Round Robin

각 프로세스에게 동일 크기의 CPU 할당 시간을 부여합니다.

할당 시간이 끝나면 인터럽트가 발생하여 프로세스는 CPU를 빼앗기고 CPU 큐의 제일 뒤에 삽입됩니다.

n개의 프로세스가 CPU 큐에 있는 경우 어떤 프로세스도 (n-1) \* 할당 시간 이상으로 대기 시간이 발생하지 않습니다.

즉, 대기 시간이 프로세스의 CPU 사용 시간에 비례합니다.

모든 프로세스가 동일한 할당 시간이 부여되니 기아 현상이 없습니다.

### 메모리 관리

컴퓨터 전원이 켜지면 운영체제는 메모리에 가장 먼저 할당됩니다.

여러 프로그램들은 운영체제를 제외한 나머지 메모리 공간에 적절히 할당돼야 합니다.

각 프로세서들은 현재 필요한 부분만 메모리에 들어가고 불필요한 부분은 각자의 가상 메모리에 저장됩니다.

불필요한 부분은 메모리에 올리지 않아 메모리를 효과적으로 관리 가능합니다.

메모리에서 쫓겨난 페이지는 Swap 영역에 저장합니다.

미래를 모르는 상황에서 미래에 다시 사용될 가능성이 높은 페이지는 유지하고 않고 가능성이 낮은 페이지는 Swap영역으로 보내는 것이 메모리 관리의 핵심입니다. 과거의 내역을 토대로 계산하며 크게 두 가지 방법이 있습니다.

#### LRU

가장 오래전에 참조된 페이지를 삭제합니다.

1번 페이지가 가장 오래전에 참조되었다면 1번을 Swap 합니다.

최근에 사용된 페이지가 재사용될 가능성이 높다고 판단합니다.

#### LFU

참조 횟수가 가장 적은 페이지를 삭제합니다. 4번이 가장 적게 참조되었다면 4번 페이지를 Swap 합니다.

과거에 많이 사용되었다면 재사용될 가능성이 높다고 판단합니다.

### 디스크 스케줄링

디스크는 헤드를 이동하며 트랙을 읽어 데이터를 전송합니다.

디스크 접근 시간(Access Time)은 아래 세 가지로 구성되어 있습니다.

1.  탐색 시간(Seek Time) : 헤드를 해당 트랙(Cylinder)으로 움직이는데 소요되는 시간
2.  회전 지연(Rotational Latency) : 헤드가 원하는 섹터에 도달하기까지 걸리는 시간
3.  전송 시간(Transfer Time) : 실제 데이터 전송 시간

Seek Time이 가장 많은 시간이 소요되기 때문에 Seek Time을 줄여야 디스크의 효율성이 증가합니다.

Seek Time을 줄이기 위해서는 헤드의 이동 거리를 최소화해야 합니다.

#### First-Come First-Served

디스크 요청은 디스크 Queue에 쌓입니다.

Queue에 쌓이는 순서대로 처리를 하면 헤드의 이동이 비효율적입니다.

끝에서 끝으로 이동하는 패턴이 반복될 수 있기 때문입니다.

#### SSTF(Shortest SEek Time First) 

현재 위치에서 가장 짧은 요청을 먼저 처리합니다.

이동 거리는 가장 짧지만 Starvation이 발생할 수 있습니다.

항상 가장 먼 거리에 있는 프로세스는 처리가 되지 않기 때문입니다.

#### SCAN

헤드가 디스크의 한쪽 끝에서 다른 쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리하는 방법입니다. 

다른 한쪽 끝에 도달하면 역방향으로 이동하며 오늘 길목에 있는 모든 요청을 처리하며 다시 반대쪽 끝으로 이동합니다.

엘리베이터 방식과 매우 유사하며 헤드의 이동 거리가 짧아집니다.
